// Copyright 08-Dec-2021 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// List[Kv *].

#ifndef DMC_KV_LKV_H
  #define DMC_KV_LKV_H

#include "dmc/List.h"
#include "dmc/Kv/OKv.h"
#include "dmc/Kv/AKv.h"

#include "dmc/Kv.h"

/// List[Kv *].
struct lKv_LKv {
  struct lKv_LKv *next;
  Kv *value;
};

/// List[Kv *].
typedef struct lKv_LKv LKv;

/// Creates a new List.
LKv *lKv_new(void);

/// Returns the number of elements. (O(n) operation).
int lKv_size(LKv *this);

/// Returns every element of 'this' less the first one. If "this" is
/// empty, throws an exception.
LKv *lKv_tail(LKv *this);

/// Returns the first element of 'this'. If "this" is empty.
/// throws an exception.
Kv *lKv_head (LKv *this);

/// Returns the element in 'ix' position -- head is in position 0.
/// (O(n) operation).
OKv *lKv_get (LKv *this, int ix);

/// Returns '1' if 'this' is empty.
int lKv_empty(LKv *this);

/// Adds 'o' at head. 'o' must be not NULL.
LKv *lKv_cons(LKv *this, Kv *o);

/// Returns 'this + l'.
LKv *lKv_cat(LKv *this, LKv *l);

/// lKv_reverse returns this in reverse order.
LKv *lKv_reverse(LKv *this);

/// Sorts 'this' ascendantly using the function 'greater' that returns '1'
/// if 'e1' > 'e2'.
LKv *lKv_sort (LKv *this, int (*greater)(Kv *e1, Kv *e2));

/// Returns '1' if every element of 'this' yields '1' with 'pred'.
int lKv_all (LKv *this, int (*pred)(Kv *e));

/// Returns '1' if some element of 'this' yields '1' with 'pred'.
int lKv_any (LKv *this, int (*pred)(Kv *e));

/// Returns the index of the first elements which returns '1'
/// with 'pred', or -1 if such element does not exist.
int lKv_index (LKv *this, int (*pred)(Kv *e));

/// Returns the index of the last elements which returns '1'
/// with 'pred', or -1 if such element does not exist.
int lKv_last_index (LKv *this, int (*pred)(Kv *e));

/// Returns the first element which pruduces '1' with 'pred' or 'opt_none'.
OKv *lKv_find(LKv *this, int (*pred)(Kv *e));

/// Returns the last element which pruduces '1' with 'pred' or 'opt_none'.
OKv *lKv_find_last(LKv *this, int (*pred)(Kv *e));

/// Returns a new List with every element which returns '1' with 'pred'.
LKv *lKv_filter (LKv *this, int (*pred)(Kv *e));

/// Returns a new Arr with the n first elements of this.
/// If this has less elements than n, returs a copy of this.
LKv *lKv_take (LKv *this, int n);

/// Returns a new Arr with the first elements which return '1' with 'pred'.
LKv *lKv_takef (LKv *this, int (*pred)(Kv *e));

/// Returns a new Arr with elements left after arr_take.
LKv *lKv_drop (LKv *this, int n);

/// Returns a new Arr with elements left after arr_takef.
LKv *lKv_dropf (LKv *this, int (*pred)(Kv *e));

/// Returns a new List with elements generated by converter.
List *lKv_map (LKv *this, void *(*converter)(Kv *e));

/// Returns a new List whit the first element generated by conv1 and the rest
/// by conv2.
List *lKv_map2 (LKv *this, void *(*conv1)(Kv *e), void *(*conv2)(Kv *e));

/// Returns a new List mixing values of 'l1' and 'l2'. The size of the resultant
/// List is the less of 'l1' size and 'l2' size.
List *lKv_zip (LKv *l1, LKv *l2, void *(*converter)(Kv *e1, Kv *e2));

/// Returns a new List mixing values of 'l1', 'l2' and 'l3'. The List of the
/// resultant List is the less of 'l1' size, 'l2' size and 'l3' size.
List *lKv_zip3 (
  LKv *l1, LKv *l2, LKv *l3,
  void *(*converter)(Kv *e1, Kv *e2, Kv *e3)
);

/// Returns an Arr with 'this' elements.
AKv *lKv_to_arr (LKv *this);

/// Returns a list with 'a' elements.
LKv *lKv_from_arr (AKv *a);

/// lKv_to_json returns a serialization of 'this' using 'to' to.
/// convert elements.
char *lKv_to_js(LKv *this, char *(*to)(Kv *));

/// lKv_from_json restores a serialized List using 'from' to convert elements.
LKv *lKv_from_js(char *js, Kv *(*from)(char *));


//--// Not remove

#endif